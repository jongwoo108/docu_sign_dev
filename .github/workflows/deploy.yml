name: "CI/CD to EKS"

on:
  push:
    branches: ["main"]
    paths-ignore:
      - "README.md"
  workflow_dispatch: {}

concurrency:
  group: production-deploy
  cancel-in-progress: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 25
    permissions:
      id-token: write
      contents: read

    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      EKS_CLUSTER_NAME: ${{ secrets.EKS_CLUSTER_NAME }}
      K8S_NAMESPACE: ${{ secrets.K8S_NAMESPACE }}
      CONTAINER_NAME: web
      # kubeconfig 경로 (runner.temp 대신 workspace 사용)
      KUBECONFIG_PATH: ${{ github.workspace }}/kubeconfig
      # kubectl이 기본으로 동일 kubeconfig를 보도록 환경변수도 지정
      KUBECONFIG: ${{ github.workspace }}/kubeconfig

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Debug - Check AWS identity and permissions
        run: |
          echo "=== AWS Identity ==="
          aws sts get-caller-identity
          echo ""
          echo "=== EKS Cluster Info ==="
          aws eks describe-cluster --name "${EKS_CLUSTER_NAME}" --region "${AWS_REGION}" --query 'cluster.{name:name,status:status,version:version,arn:arn}' || true
          echo ""
          echo "=== ENV ==="
          echo "AWS_REGION=${AWS_REGION}"
          echo "EKS_CLUSTER_NAME=${EKS_CLUSTER_NAME}"
          echo "K8S_NAMESPACE=${K8S_NAMESPACE}"

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region "${AWS_REGION}" \
          | docker login --username AWS --password-stdin \
            "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Build & Push Docker image (tag=short SHA + latest)
        id: push-image
        run: |
          set -euxo pipefail
          REPO="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}"
          IMAGE_TAG="${GITHUB_SHA::7}"
          docker build -f docker/Dockerfile -t "${REPO}:${IMAGE_TAG}" .
          docker tag "${REPO}:${IMAGE_TAG}" "${REPO}:latest"
          docker push "${REPO}:${IMAGE_TAG}"
          docker push "${REPO}:latest"
          echo "IMAGE=${REPO}:${IMAGE_TAG}" >> "$GITHUB_ENV"

      - name: Install kubectl (if missing)
        run: |
          if ! command -v kubectl >/dev/null; then
            curl -sSL -o kubectl https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
            chmod +x kubectl && sudo mv kubectl /usr/local/bin/kubectl
          fi

      - name: Update kubeconfig
        id: kubeconfig
        run: |
          set -euxo pipefail
          aws eks update-kubeconfig \
            --name "${EKS_CLUSTER_NAME}" \
            --region "${AWS_REGION}" \
            --kubeconfig "${KUBECONFIG_PATH}"
          kubectl --kubeconfig "${KUBECONFIG_PATH}" version --client
          echo "KUBECONFIG_READY=true" >> "$GITHUB_ENV"

      # === kubectl 사용 전: kubeconfig 경로/자격 재주입 ===
      - name: Export KUBECONFIG
        if: env.KUBECONFIG_READY == 'true'
        run: echo "KUBECONFIG=${KUBECONFIG_PATH}" >> "$GITHUB_ENV"

      - name: Reconfigure AWS credentials (for kubectl)
        if: env.KUBECONFIG_READY == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: RBAC sanity check
        if: env.KUBECONFIG_READY == 'true'
        run: |
          kubectl -n "${K8S_NAMESPACE}" auth can-i patch deployment
          kubectl -n "${K8S_NAMESPACE}" auth can-i get pods
          kubectl -n "${K8S_NAMESPACE}" auth can-i list deployments
        continue-on-error: true

      - name: Resolve container name (auto-detect)
        if: env.KUBECONFIG_READY == 'true'
        run: |
          CN="${CONTAINER_NAME}"
          # secrets.CONTAINER_NAME 우선
          if [ -n "${{ secrets.CONTAINER_NAME }}" ]; then
            CN="${{ secrets.CONTAINER_NAME }}"
          else
            # 디폴트: documenso 디플로이의 첫 번째 컨테이너명 or 'web'
            CN="$(kubectl -n "${K8S_NAMESPACE}" \
                  get deploy/documenso -o jsonpath='{.spec.template.spec.containers[0].name}' 2>/dev/null || echo 'web')"
          fi
          echo "USING_CONTAINER=${CN}" >> "$GITHUB_ENV"
          echo "Using container: ${CN}"
        continue-on-error: true

      # ===== 커밋마다 롤아웃 강제 (Pod 템플릿 어노테이션에 SHA 주입) =====
      - name: Force rollout by annotating pod template with commit SHA
        if: env.KUBECONFIG_READY == 'true'
        run: |
          set -euxo pipefail
          kubectl -n "${K8S_NAMESPACE}" patch deploy/documenso \
            -p "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"ci.commitSha\":\"${GITHUB_SHA}\"}}}}}"

      # ===== 새 이미지로 교체(커밋 SHA 태그) =====
      - name: Rolling update with new image tag
        if: env.KUBECONFIG_READY == 'true'
        run: |
          set -euxo pipefail
          echo "=== Rolling update ==="
          echo "Image: ${IMAGE}"
          echo "Container: ${USING_CONTAINER}"
          kubectl -n "${K8S_NAMESPACE}" \
            set image deploy/documenso "${USING_CONTAINER}"="${IMAGE}"
          # (선택) imagePullPolicy=Always 보정 - 없으면 추가, 있으면 무시
          kubectl -n "${K8S_NAMESPACE}" patch deploy/documenso --type='json' -p='[
            {"op":"add","path":"/spec/template/spec/containers/0/imagePullPolicy","value":"Always"}
          ]' || true
          kubectl -n "${K8S_NAMESPACE}" \
            annotate deploy/documenso kubernetes.io/change-cause="GitHub ${GITHUB_SHA}" --overwrite
          kubectl -n "${K8S_NAMESPACE}" \
            rollout status deploy/documenso --timeout=180s

      - name: Verify running image
        if: env.KUBECONFIG_READY == 'true'
        run: |
          kubectl -n "${K8S_NAMESPACE}" get deploy documenso \
            -o jsonpath='{range .spec.template.spec.containers[*]}{.name}{" => "}{.image}{"\n"}{end}'
          echo "---- Pod imageIDs ----"
          kubectl -n "${K8S_NAMESPACE}" get pods -l app=documenso \
            -o jsonpath='{range .items[*]}{.metadata.name}{" -> "}{.status.containerStatuses[0].imageID}{"\n"}{end}'

      # === 실패 시에도 자격/환경 보장 후 롤백 ===
      - name: Reconfigure AWS credentials (rollback)
        if: failure() && env.KUBECONFIG_READY == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Export KUBECONFIG (rollback)
        if: failure() && env.KUBECONFIG_READY == 'true'
        run: echo "KUBECONFIG=${KUBECONFIG_PATH}" >> "$GITHUB_ENV"

      - name: On failure → Rollback
        if: failure() && env.KUBECONFIG_READY == 'true'
        run: |
          echo "=== Rolling back deployment ==="
          kubectl -n "${K8S_NAMESPACE}" rollout undo deploy/documenso
        continue-on-error: true
