name: "CI/CD to EKS"

on:
  push:
    branches: ["main"]
    paths-ignore:
      - "README.md"
  workflow_dispatch: {}

concurrency:
  group: production-deploy
  cancel-in-progress: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 25
    permissions:
      id-token: write
      contents: read

    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      EKS_CLUSTER_NAME: ${{ secrets.EKS_CLUSTER_NAME }}
      K8S_NAMESPACE: ${{ secrets.K8S_NAMESPACE }}
      # 실제 배포 컨테이너 기본값(배포에 맞춤)
      CONTAINER_NAME: web
      KUBECONFIG_PATH: ${{ runner.temp }}/kubeconfig

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Who am I
        run: aws sts get-caller-identity

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region "${AWS_REGION}" \
          | docker login --username AWS --password-stdin \
            "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Build & Push Docker image
        id: push-image
        run: |
          set -euxo pipefail
          REPO="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}"
          IMAGE_TAG="${GITHUB_SHA::7}"
          docker build -t "${REPO}:${IMAGE_TAG}" .
          docker push "${REPO}:${IMAGE_TAG}"
          echo "IMAGE=${REPO}:${IMAGE_TAG}" >> $GITHUB_ENV

      - name: Update kubeconfig
        id: kubeconfig
        run: |
          set -euxo pipefail
          aws eks update-kubeconfig \
            --name "${EKS_CLUSTER_NAME}" \
            --region "${AWS_REGION}" \
            --kubeconfig "${KUBECONFIG_PATH}"
          kubectl --kubeconfig "${KUBECONFIG_PATH}" version --short
          echo "KUBECONFIG_READY=true" >> $GITHUB_ENV

      - name: RBAC sanity check
        if: env.KUBECONFIG_READY == 'true'
        run: kubectl --kubeconfig "${KUBECONFIG_PATH}" -n "${K8S_NAMESPACE}" auth can-i patch deployment

      # 컨테이너 이름 자동 감지(Secrets에 CONTAINER_NAME가 있으면 그 값을 우선)
      - name: Resolve container name (auto-detect)
        run: |
          CN="${CONTAINER_NAME}"
          if [ -n "${{ secrets.CONTAINER_NAME }}" ]; then
            CN="${{ secrets.CONTAINER_NAME }}"
          else
            CN="$(kubectl --kubeconfig "${KUBECONFIG_PATH}" -n "${K8S_NAMESPACE}" \
                  get deploy/documenso -o jsonpath='{.spec.template.spec.containers[0].name}')"
          fi
          echo "USING_CONTAINER=${CN}" >> $GITHUB_ENV
          echo "Using container: ${CN}"

      - name: Rolling update
        if: env.KUBECONFIG_READY == 'true'
        run: |
          set -euxo pipefail
          kubectl --kubeconfig "${KUBECONFIG_PATH}" -n "${K8S_NAMESPACE}" \
            set image deploy/documenso "${USING_CONTAINER}"="${IMAGE}"
          kubectl --kubeconfig "${KUBECONFIG_PATH}" -n "${K8S_NAMESPACE}" \
            rollout status deploy/documenso --timeout=180s

      - name: On failure → Rollback
        if: failure() && env.KUBECONFIG_READY == 'true'
        run: |
          kubectl --kubeconfig "${KUBECONFIG_PATH}" -n "${K8S_NAMESPACE}" \
            rollout undo deploy/documenso
